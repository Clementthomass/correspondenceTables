% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/retrieveCorrespondenceTable..R,
%   R/retrieveCorrespondenceTable.R
\name{retrieveCorrespondenceTable}
\alias{retrieveCorrespondenceTable}
\title{Retrieve correspondence tables between statistical classifications from CELLAR and FAO repositories.}
\usage{
retrieveCorrespondenceTable(
  endpoint,
  prefix,
  ID_table,
  language = "en",
  CSVout = NULL,
  showQuery = TRUE,
  localData = NULL
)

retrieveCorrespondenceTable(
  endpoint,
  prefix,
  ID_table,
  language = "en",
  CSVout = NULL,
  showQuery = TRUE,
  localData = NULL
)
}
\arguments{
\item{endpoint}{SPARQL endpoints provide a standardized way to access data sets,
making it easier to retrieve specific information or perform complex queries on linked data.
The valid values are \code{"CELLAR"} or \code{"FAO"}.}

\item{prefix}{The namespace prefix identifying the correspondence table to retrieve.
Available prefixes can be found using the \code{correspondenceTableList()} function.}

\item{ID_table}{Refers to a unique identifier associated with a specific correspondence table.
The ID_table can be obtained by utilizing the "correspondenceTableList()" function.}

\item{language}{Refers to the specific language used for providing label, include and exclude information in the selected correspondence table.
By default is set to "en". This is an optional argument.}

\item{CSVout}{The valid value is a valid path to a csv file including file name and extension. By default, no csv file is produced, \code{NULL}}

\item{showQuery}{The valid values are \code{FALSE} or \code{TRUE}. In both cases the correspondence table as an R object.
If not needed to view the SPARQL query used, the argument should be set as \code{FALSE}. By default, the SPARQL query is produced.}

\item{localData}{Logical. If TRUE, the function retrieves static (local) data embedded in the package instead of querying the remote SPARQL endpoint. Default is FALSE.}
}
\value{
If \code{showQuery = TRUE}, a list with:
\itemize{
  \item \code{SPARQL.query}: the full SPARQL query,
  \item \code{CorrespondenceTable}: a data frame containing one row per
        mapping between source and target codes.
}

If \code{showQuery = FALSE}, only the correspondence table
(data frame) is returned.

The returned table may contain the following columns:
\itemize{
  \item \code{<A>}: code in the source classification,
  \item \code{<B>}: code in the target classification,
  \item \code{Label_<A>}: label of the source code,
  \item \code{Include_<A>}, \code{Exclude_<A>}: source notes,
  \item \code{Label_<B>}: label of the target code,
  \item \code{Include_<B>}, \code{Exclude_<B>}: target notes,
  \item \code{Comment}: optional mapping-level comment,
  \item \code{URL}: URI of the association object.
}

\code{retrieveCorrespondenceTable()} returns a classification tables from CELLAR and FAO. The table includes the following variables:
 \itemize{
    \item Source Classification name (e.g. cn2019): the code of each object in the source classification
    \item Source Classification name (e.g. cn2021): the code of each object in the target classification
    \item Target Classification label: the corresponding label of each object (e.g. cn2019)
    \item Include: include details on each object (e.g. cn2019)
    \item Exclude: details on each object (e.g. cn2019)
    \item Target Classification label: the corresponding label of each object (e.g. cn2021)
    \item Include: include details on each object (e.g. cn2021)
    \item Exclude: details on each object (e.g. cn2021)
    \item Comment: details on each object, if available
    \item URL: the URL from which the SPARQL query was retrieved
   
}

If \code{showQuery = TRUE}, the function returns a list of two elements:
\itemize{
  \item A character string containing the SPARQL query used.
  \item A \code{data.frame} containing the retrieved classification or correspondence table.
}
If \code{showQuery = FALSE}, the function returns only the \code{data.frame}.
}
\description{
This function retrieves a correspondence (mapping) table between two
statistical classifications stored as Linked Open Data in the CELLAR or
FAO repositories. A correspondence table links codes from a *source*
classification to related codes in a *target* classification, together
with optional labels and notes (include, exclude, comments).

The function automatically:
\itemize{
  \item identifies the source and target classification prefixes from
        \code{ID_table},
  \item builds the required SPARQL namespace declarations using
        \code{\link{prefixList}},
  \item issues a SPARQL query against the selected endpoint,
  \item extracts labels and notes in the requested language.
}

Retrieve correspondence tables between classifications from the CELLAR and FAO repositories
}
\details{
Internally, the function:
\itemize{
  \item builds SPARQL prefixes from the source and target classifications,
  \item queries the repository for:
        \itemize{
          \item source code
          \item target code
          \item labels in the selected language
          \item include/exclude notes
          \item optional mapping comments
        }
  \item ensures that only plain-literal notations are kept if multiple
        datatypes exist,
  \item removes datatype columns before returning the final table.
}

The behaviour of this function is contingent on the global option \code{useLocalDataForVignettes}:
The default behaviour (when the option is not set, or set to something else than \code{TRUE}), is that queries live SPARQL endpoints online.
When the option is set to \code{TRUE} via \code{options(useLocalDataForVignettes = TRUE)}, the function returns local (embedded) data instead of querying live SPARQL endpoints.
This is useful for building vignettes or offline testing.
}
\examples{
\dontrun{
  endpoint <- "CELLAR"
  prefix   <- "cn2022"
  ID_table <- "CN2022_NST2007"

  results <- retrieveCorrespondenceTable(prefix, endpoint, ID_table)

  # Show SPARQL query
  cat(results$SPARQL.query)

  # Show the first rows of the correspondence table
  head(results$CorrespondenceTable)
}

if (interactive()) {
  endpoint = "CELLAR"
  prefix = "cn2022"
  ID_table = "CN2022_NST2007"
  results_ls = try(retrieveCorrespondenceTable(endpoint, prefix, ID_table), silent = TRUE)
  if (!inherits(results_ls, "try-error") && is.character(results_ls[[1]])) {
    cat(results_ls[[1]])
  }
  # if (!inherits(results_ls, "try-error")) View(results_ls[[2]])
}
}
\seealso{
\code{\link{prefixList}},
\code{\link{classificationEndpoint}},
\code{\link{retrieveClassificationTable}}
}
